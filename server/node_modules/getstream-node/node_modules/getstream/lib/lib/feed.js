"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _user = _interopRequireDefault(require("./user"));

var _errors = _interopRequireDefault(require("./errors"));

var _utils = _interopRequireDefault(require("./utils"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Manage api calls for specific feeds
 * The feed object contains convenience functions such add activity, remove activity etc
 * @class StreamFeed
 */
var StreamFeed = /*#__PURE__*/function () {
  function StreamFeed(client, feedSlug, userId, token) {
    (0, _classCallCheck2.default)(this, StreamFeed);

    /**
     * Initialize a feed object
     * @method constructor
     * @memberof StreamFeed.prototype
     * @param {StreamClient} client - The stream client this feed is constructed from
     * @param {string} feedSlug - The feed slug
     * @param {string} userId - The user id
     * @param {string} [token] - The authentication token
     */
    if (!feedSlug || !userId) {
      throw new _errors.default.FeedError('Please provide a feed slug and user id, ie client.feed("user", "1")');
    }

    if (feedSlug.indexOf(':') !== -1) {
      throw new _errors.default.FeedError('Please initialize the feed using client.feed("user", "1") not client.feed("user:1")');
    }

    _utils.default.validateFeedSlug(feedSlug);

    _utils.default.validateUserId(userId); // raise an error if there is no token


    if (!token) {
      throw new _errors.default.FeedError('Missing token, in client side mode please provide a feed secret');
    }

    this.client = client;
    this.slug = feedSlug;
    this.userId = userId;
    this.id = "".concat(this.slug, ":").concat(this.userId);
    this.token = token;
    this.feedUrl = this.id.replace(':', '/');
    this.feedTogether = this.id.replace(':', '');
    this.signature = "".concat(this.feedTogether, " ").concat(this.token); // faye setup

    this.notificationChannel = "site-".concat(this.client.appId, "-feed-").concat(this.feedTogether);
    this.enrichByDefault = false;
  }

  (0, _createClass2.default)(StreamFeed, [{
    key: "addActivity",
    value: function addActivity(activity) {
      /**
       * Adds the given activity to the feed
       * @method addActivity
       * @memberof StreamFeed.prototype
       * @param {object} activity - The activity to add
       * @return {Promise} Promise object
       */
      activity = _utils.default.replaceStreamObjects(activity);

      if (!activity.actor && this.client.currentUser) {
        activity.actor = this.client.currentUser.ref();
      }

      return this.client.post({
        url: "feed/".concat(this.feedUrl, "/"),
        body: activity,
        signature: this.signature
      });
    }
  }, {
    key: "removeActivity",
    value: function removeActivity(activityId) {
      /**
       * Removes the activity by activityId
       * @method removeActivity
       * @memberof StreamFeed.prototype
       * @param  {string}   activityId Identifier of activity to remove
       * @return {Promise} Promise object
       * @example
       * feed.removeActivity(activityId);
       * @example
       * feed.removeActivity({'foreignId': foreignId});
       */
      return this.client.delete({
        url: "feed/".concat(this.feedUrl, "/").concat(activityId.foreignId || activityId, "/"),
        qs: activityId.foreignId ? {
          foreign_id: '1'
        } : {},
        signature: this.signature
      });
    }
  }, {
    key: "addActivities",
    value: function addActivities(activities) {
      /**
       * Adds the given activities to the feed
       * @method addActivities
       * @memberof StreamFeed.prototype
       * @param  {Array}   activities Array of activities to add
       * @return {Promise}               XHR request object
       */
      return this.client.post({
        url: "feed/".concat(this.feedUrl, "/"),
        body: {
          activities: _utils.default.replaceStreamObjects(activities)
        },
        signature: this.signature
      });
    }
  }, {
    key: "follow",
    value: function follow(targetSlug, targetUserId) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      /**
       * Follows the given target feed
       * @method follow
       * @memberof StreamFeed.prototype
       * @param  {string}   targetSlug   Slug of the target feed
       * @param  {string}   targetUserId User identifier of the target feed
       * @param  {object}   options      Additional options
       * @param  {number}   options.activityCopyLimit Limit the amount of activities copied over on follow
       * @return {Promise}  Promise object
       * @example feed.follow('user', '1');
       * @example feed.follow('user', '1');
       * @example feed.follow('user', '1', options);
       */
      if (targetUserId instanceof _user.default) {
        targetUserId = targetUserId.id;
      }

      _utils.default.validateFeedSlug(targetSlug);

      _utils.default.validateUserId(targetUserId);

      var body = {
        target: "".concat(targetSlug, ":").concat(targetUserId)
      };
      if (typeof options.limit === 'number') body.activity_copy_limit = options.limit;
      return this.client.post({
        url: "feed/".concat(this.feedUrl, "/following/"),
        body: body,
        signature: this.signature
      });
    }
  }, {
    key: "unfollow",
    value: function unfollow(targetSlug, targetUserId) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      /**
       * Unfollow the given feed
       * @method unfollow
       * @memberof StreamFeed.prototype
       * @param  {string}   targetSlug   Slug of the target feed
       * @param  {string}   targetUserId [description]
       * @param  {object} options
       * @param  {boolean}  options.keepHistory when provided the activities from target
       *                                                 feed will not be kept in the feed
       * @return {object}                XHR request object
       * @example feed.unfollow('user', '2');
       */
      var qs = {};
      if (typeof options.keepHistory === 'boolean' && options.keepHistory) qs.keep_history = '1';

      _utils.default.validateFeedSlug(targetSlug);

      _utils.default.validateUserId(targetUserId);

      var targetFeedId = "".concat(targetSlug, ":").concat(targetUserId);
      return this.client.delete({
        url: "feed/".concat(this.feedUrl, "/following/").concat(targetFeedId, "/"),
        qs: qs,
        signature: this.signature
      });
    }
  }, {
    key: "following",
    value: function following() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * List which feeds this feed is following
       * @method following
       * @memberof StreamFeed.prototype
       * @param  {object}   options  Additional options
       * @param  {string}   options.filter Filter to apply on search operation
       * @return {Promise} Promise object
       * @example feed.following({limit:10, filter: ['user:1', 'user:2']});
       */
      if (options.filter) {
        options.filter = options.filter.join(',');
      }

      return this.client.get({
        url: "feed/".concat(this.feedUrl, "/following/"),
        qs: options,
        signature: this.signature
      });
    }
  }, {
    key: "followers",
    value: function followers() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * List the followers of this feed
       * @method followers
       * @memberof StreamFeed.prototype
       * @param  {object}   options  Additional options
       * @param  {string}   options.filter Filter to apply on search operation
       * @return {Promise} Promise object
       * @example
       * feed.followers({limit:10, filter: ['user:1', 'user:2']});
       */
      if (options.filter) {
        options.filter = options.filter.join(',');
      }

      return this.client.get({
        url: "feed/".concat(this.feedUrl, "/followers/"),
        qs: options,
        signature: this.signature
      });
    }
  }, {
    key: "get",
    value: function get() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      /**
       * Reads the feed
       * @method get
       * @memberof StreamFeed.prototype
       * @param  {object}   options  Additional options
       * @return {Promise} Promise object
       * @example feed.get({limit: 10, id_lte: 'activity-id'})
       * @example feed.get({limit: 10, mark_seen: true})
       */
      if (options.mark_read && options.mark_read.join) {
        options.mark_read = options.mark_read.join(',');
      }

      if (options.mark_seen && options.mark_seen.join) {
        options.mark_seen = options.mark_seen.join(',');
      }

      this.client.replaceReactionOptions(options);
      var path = this.client.shouldUseEnrichEndpoint(options) ? 'enrich/feed/' : 'feed/';
      return this.client.get({
        url: "".concat(path).concat(this.feedUrl, "/"),
        qs: options,
        signature: this.signature
      });
    }
  }, {
    key: "getActivityDetail",
    value: function getActivityDetail(activityId, options) {
      /**
       * Retrieves one activity from a feed and adds enrichment
       * @method getActivityDetail
       * @memberof StreamFeed.prototype
       * @param  {string}   activityId Identifier of activity to retrieve
       * @param  {object}   options  Additional options
       * @return {Promise} Promise object
       * @example feed.getActivityDetail(activityId)
       * @example feed.getActivityDetail(activityId, {withRecentReactions: true})
       * @example feed.getActivityDetail(activityId, {withReactionCounts: true})
       * @example feed.getActivityDetail(activityId, {withOwnReactions: true, withReactionCounts: true})
       */
      return this.get(_objectSpread({
        id_lte: activityId,
        id_gte: activityId,
        limit: 1
      }, options || {}));
    }
  }, {
    key: "getFayeClient",
    value: function getFayeClient() {
      /**
       * Returns the current faye client object
       * @method getFayeClient
       * @memberof StreamFeed.prototype
       * @access private
       * @return {object} Faye client
       */
      return this.client.getFayeClient();
    }
  }, {
    key: "subscribe",
    value: function subscribe(callback) {
      /**
       * Subscribes to any changes in the feed, return a promise
       * @method subscribe
       * @memberof StreamFeed.prototype
       * @param  {function} callback Callback to call on completion
       * @return {Promise}           Promise object
       * @example
       * feed.subscribe(callback).then(function(){
       * 		console.log('we are now listening to changes');
       * });
       */
      if (!this.client.appId) {
        throw new _errors.default.SiteError('Missing app id, which is needed to subscribe, use var client = stream.connect(key, secret, appId);');
      }

      var subscription = this.getFayeClient().subscribe("/".concat(this.notificationChannel), callback);
      this.client.subscriptions["/".concat(this.notificationChannel)] = {
        token: this.token,
        userId: this.notificationChannel,
        fayeSubscription: subscription
      };
      return subscription;
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      /**
       * Cancel updates created via feed.subscribe()
       * @return void
       */
      var streamSubscription = this.client.subscriptions["/".concat(this.notificationChannel)];

      if (streamSubscription) {
        delete this.client.subscriptions["/".concat(this.notificationChannel)];
        streamSubscription.fayeSubscription.cancel();
      }
    }
  }, {
    key: "updateActivityToTargets",
    value: function updateActivityToTargets(foreignId, time, newTargets, addedTargets, removedTargets) {
      /**
       * Updates an activity's "to" fields
       * @since 3.10.0
       * @param {string} foreignId The foreign_id of the activity to update
       * @param {string} time The time of the activity to update
       * @param {array} newTargets Set the new "to" targets for the activity - will remove old targets
       * @param {array} added_targets Add these new targets to the activity
       * @param {array} removedTargets Remove these targets from the activity
       */
      if (!foreignId) {
        throw new Error('Missing `foreign_id` parameter!');
      } else if (!time) {
        throw new Error('Missing `time` parameter!');
      }

      if (!newTargets && !addedTargets && !removedTargets) {
        throw new Error('Requires you to provide at least one parameter for `newTargets`, `addedTargets`, or `removedTargets` - example: `updateActivityToTargets("foreignID:1234", new Date(), [newTargets...], [addedTargets...], [removedTargets...])`');
      }

      if (newTargets) {
        if (addedTargets || removedTargets) {
          throw new Error("Can't include add_targets or removedTargets if you're also including newTargets");
        }
      }

      if (addedTargets && removedTargets) {
        // brute force - iterate through added, check to see if removed contains that element
        addedTargets.forEach(function (addedTarget) {
          if (removedTargets.includes(addedTarget)) {
            throw new Error("Can't have the same feed ID in addedTargets and removedTargets.");
          }
        });
      }

      var body = {
        foreign_id: foreignId,
        time: time
      };
      if (newTargets) body.new_targets = newTargets;
      if (addedTargets) body.added_targets = addedTargets;
      if (removedTargets) body.removed_targets = removedTargets;
      return this.client.post({
        url: "feed_targets/".concat(this.feedUrl, "/activity_to_targets/"),
        signature: this.signature,
        body: body
      });
    }
  }]);
  return StreamFeed;
}();

exports.default = StreamFeed;