"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _axios = _interopRequireDefault(require("axios"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _faye = _interopRequireDefault(require("faye"));

var _jwtDecode = _interopRequireDefault(require("jwt-decode"));

var _personalization = _interopRequireDefault(require("./personalization"));

var _batch_operations = _interopRequireDefault(require("./batch_operations"));

var _collections = _interopRequireDefault(require("./collections"));

var _feed = _interopRequireDefault(require("./feed"));

var _files = _interopRequireDefault(require("./files"));

var _images = _interopRequireDefault(require("./images"));

var _reaction = _interopRequireDefault(require("./reaction"));

var _user = _interopRequireDefault(require("./user"));

var _redirect_url = _interopRequireDefault(require("./redirect_url"));

var _signing = _interopRequireDefault(require("./signing"));

var _errors = _interopRequireDefault(require("./errors"));

var _utils = _interopRequireDefault(require("./utils"));

var _package = _interopRequireDefault(require("../../package.json"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Client to connect to Stream api
 * @class StreamClient
 */
var StreamClient = /*#__PURE__*/function () {
  function StreamClient(apiKey, apiSecretOrToken, appId) {
    var _this = this;

    var _options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    (0, _classCallCheck2.default)(this, StreamClient);
    (0, _defineProperty2.default)(this, "replaceReactionOptions", function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Shortcut options for reaction enrichment
      if (options.reactions) {
        if (options.reactions.own != null) {
          options.withOwnReactions = options.reactions.own;
        }

        if (options.reactions.recent != null) {
          options.withRecentReactions = options.reactions.recent;
        }

        if (options.reactions.counts != null) {
          options.withReactionCounts = options.reactions.counts;
        }

        if (options.reactions.own_children != null) {
          options.withOwnChildren = options.reactions.own_children;
        }

        delete options.reactions;
      }
    });
    (0, _defineProperty2.default)(this, "handleResponse", function (response) {
      if (/^2/.test("".concat(response.status))) {
        _this.send('response', null, response, response.data);

        return response.data;
      }

      throw new _errors.default.StreamApiError("".concat(JSON.stringify(response.data), " with HTTP status code ").concat(response.status), response.data, response);
    });
    (0, _defineProperty2.default)(this, "doAxiosRequest", /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(method, options) {
        var response;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this.send('request', method, options);

                _context.prev = 1;
                _context.next = 4;
                return _this.request(_this.enrichKwargs(_objectSpread({
                  method: method
                }, options)));

              case 4:
                response = _context.sent;
                return _context.abrupt("return", _this.handleResponse(response));

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](1);

                if (!_context.t0.response) {
                  _context.next = 12;
                  break;
                }

                return _context.abrupt("return", _this.handleResponse(_context.t0.response));

              case 12:
                throw new _errors.default.SiteError(_context.t0.message);

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 8]]);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());

    /**
     * Initialize a client
     * @method initialize
     * @memberof StreamClient.prototype
     * @param {string} apiKey - the api key
     * @param {string} [apiSecret] - the api secret
     * @param {string} [appId] - id of the app
     * @param {object} [options] - additional options
     * @param {string} [options.location] - which data center to use
     * @param {boolean} [options.expireTokens=false] - whether to use a JWT timestamp field (i.e. iat)
     * @example <caption>initialize is not directly called by via stream.connect, ie:</caption>
     * stream.connect(apiKey, apiSecret)
     * @example <caption>secret is optional and only used in server side mode</caption>
     * stream.connect(apiKey, null, appId);
     */
    this.baseUrl = 'https://api.stream-io-api.com/api/';
    this.baseAnalyticsUrl = 'https://analytics.stream-io-api.com/analytics/';
    this.apiKey = apiKey;
    this.usingApiSecret = apiSecretOrToken != null && !_signing.default.isJWT(apiSecretOrToken);
    this.apiSecret = this.usingApiSecret ? apiSecretOrToken : null;
    this.userToken = this.usingApiSecret ? null : apiSecretOrToken;
    this.enrichByDefault = !this.usingApiSecret;

    if (this.userToken != null) {
      var jwtBody = (0, _jwtDecode.default)(this.userToken);

      if (!jwtBody.user_id) {
        throw new TypeError('user_id is missing in user token');
      }

      this.userId = jwtBody.user_id;
      this.currentUser = this.user(this.userId);
      this.authPayload = jwtBody;
    }

    this.appId = appId;
    this.options = _options;
    this.version = this.options.version || 'v1.0';
    this.fayeUrl = this.options.fayeUrl || 'https://faye-us-east.stream-io-api.com/faye';
    this.fayeClient = null; // track a source name for the api calls, ie get started or databrowser

    this.group = this.options.group || 'unspecified'; // track subscriptions made on feeds created by this client

    this.subscriptions = {};
    this.expireTokens = this.options.expireTokens ? this.options.expireTokens : false; // which data center to use

    this.location = this.options.location;
    this.baseUrl = this.getBaseUrl();

    if (typeof process !== 'undefined' && process.env.LOCAL_FAYE) {
      this.fayeUrl = 'http://localhost:9999/faye/';
    }

    if (typeof process !== 'undefined' && process.env.STREAM_ANALYTICS_BASE_URL) {
      this.baseAnalyticsUrl = process.env.STREAM_ANALYTICS_BASE_URL;
    }

    this.handlers = {};
    this.browser = typeof this.options.browser !== 'undefined' ? this.options.browser : typeof window !== 'undefined';
    this.node = !this.browser;

    if (this.node) {
      var keepAlive = this.options.keepAlive === undefined ? true : this.options.keepAlive;
      this.nodeOptions = {
        httpAgent: new _http.default.Agent({
          keepAlive: keepAlive,
          keepAliveMsecs: 3000
        }),
        httpsAgent: new _https.default.Agent({
          keepAlive: keepAlive,
          keepAliveMsecs: 3000
        })
      };
    }

    this.request = _axios.default.create(_objectSpread({
      timeout: this.options.timeout || 10 * 1000,
      // 10 seconds
      withCredentials: false
    }, this.nodeOptions || {}));
    this.personalization = new _personalization.default(this);

    if (this.browser && this.usingApiSecret) {
      throw new _errors.default.FeedError('You are publicly sharing your App Secret. Do not expose the App Secret in browsers, "native" mobile apps, or other non-trusted environments.');
    }

    this.collections = new _collections.default(this, this.getOrCreateToken());
    this.files = new _files.default(this, this.getOrCreateToken());
    this.images = new _images.default(this, this.getOrCreateToken());
    this.reactions = new _reaction.default(this, this.getOrCreateToken());
  }

  (0, _createClass2.default)(StreamClient, [{
    key: "_throwMissingApiSecret",
    value: function _throwMissingApiSecret() {
      if (!this.usingApiSecret) {
        throw new _errors.default.SiteError('This method can only be used server-side using your API Secret, use client = stream.connect(key, secret);');
      }
    }
  }, {
    key: "getPersonalizationToken",
    value: function getPersonalizationToken() {
      if (this._personalizationToken) return this._personalizationToken;

      this._throwMissingApiSecret();

      this._personalizationToken = _signing.default.JWTScopeToken(this.apiSecret, 'personalization', '*', {
        userId: '*',
        feedId: '*',
        expireTokens: this.expireTokens
      });
      return this._personalizationToken;
    }
  }, {
    key: "getCollectionsToken",
    value: function getCollectionsToken() {
      if (this._collectionsToken) return this._collectionsToken;

      this._throwMissingApiSecret();

      this._collectionsToken = _signing.default.JWTScopeToken(this.apiSecret, 'collections', '*', {
        feedId: '*',
        expireTokens: this.expireTokens
      });
      return this._collectionsToken;
    }
  }, {
    key: "getAnalyticsToken",
    value: function getAnalyticsToken() {
      this._throwMissingApiSecret();

      return _signing.default.JWTScopeToken(this.apiSecret, 'analytics', '*', {
        userId: '*',
        expireTokens: this.expireTokens
      });
    }
  }, {
    key: "getBaseUrl",
    value: function getBaseUrl(serviceName) {
      if (!serviceName) serviceName = 'api';
      if (this.options.urlOverride && this.options.urlOverride[serviceName]) return this.options.urlOverride[serviceName];
      var urlEnvironmentKey = serviceName === 'api' ? 'STREAM_BASE_URL' : "STREAM_".concat(serviceName.toUpperCase(), "_URL");
      if (typeof process !== 'undefined' && process.env[urlEnvironmentKey]) return process.env[urlEnvironmentKey];
      if (typeof process !== 'undefined' && process.env.LOCAL || this.options.local) return "http://localhost:8000/".concat(serviceName, "/");

      if (this.location) {
        var protocol = this.options.protocol || 'https';
        return "".concat(protocol, "://").concat(this.location, "-").concat(serviceName, ".stream-io-api.com/").concat(serviceName, "/");
      }

      if (serviceName !== 'api') return "https://".concat(serviceName, ".stream-io-api.com/").concat(serviceName, "/");
      return this.baseUrl;
    }
  }, {
    key: "on",
    value: function on(event, callback) {
      /**
       * Support for global event callbacks
       * This is useful for generic error and loading handling
       * @method on
       * @memberof StreamClient.prototype
       * @param {string} event - Name of the event
       * @param {function} callback - Function that is called when the event fires
       * @example
       * client.on('request', callback);
       * client.on('response', callback);
       */
      this.handlers[event] = callback;
    }
  }, {
    key: "off",
    value: function off(key) {
      /**
       * Remove one or more event handlers
       * @method off
       * @memberof StreamClient.prototype
       * @param {string} [key] - Name of the handler
       * @example
       * client.off() removes all handlers
       * client.off(name) removes the specified handler
       */
      if (key === undefined) {
        this.handlers = {};
      } else {
        delete this.handlers[key];
      }
    }
  }, {
    key: "send",
    value: function send(key) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      /**
       * Call the given handler with the arguments
       * @method send
       * @memberof StreamClient.prototype
       * @access private
       */
      if (this.handlers[key]) this.handlers[key].apply(this, args);
    }
  }, {
    key: "userAgent",
    value: function userAgent() {
      /**
       * Get the current user agent
       * @method userAgent
       * @memberof StreamClient.prototype
       * @return {string} current user agent
       */
      return "stream-javascript-client-".concat(this.node ? 'node' : 'browser', "-").concat(_package.default.version);
    }
  }, {
    key: "getReadOnlyToken",
    value: function getReadOnlyToken(feedSlug, userId) {
      /**
       * Returns a token that allows only read operations
       *
       * @method getReadOnlyToken
       * @memberof StreamClient.prototype
       * @param {string} feedSlug - The feed slug to get a read only token for
       * @param {string} userId - The user identifier
       * @return {string} token
       * @example
       * client.getReadOnlyToken('user', '1');
       */
      _utils.default.validateFeedSlug(feedSlug);

      _utils.default.validateUserId(userId);

      return _signing.default.JWTScopeToken(this.apiSecret, '*', 'read', {
        feedId: "".concat(feedSlug).concat(userId),
        expireTokens: this.expireTokens
      });
    }
  }, {
    key: "getReadWriteToken",
    value: function getReadWriteToken(feedSlug, userId) {
      /**
       * Returns a token that allows read and write operations
       *
       * @method getReadWriteToken
       * @memberof StreamClient.prototype
       * @param {string} feedSlug - The feed slug to get a read only token for
       * @param {string} userId - The user identifier
       * @return {string} token
       * @example
       * client.getReadWriteToken('user', '1');
       */
      _utils.default.validateFeedSlug(feedSlug);

      _utils.default.validateUserId(userId);

      return _signing.default.JWTScopeToken(this.apiSecret, '*', '*', {
        feedId: "".concat(feedSlug).concat(userId),
        expireTokens: this.expireTokens
      });
    }
  }, {
    key: "feed",
    value: function feed(feedSlug) {
      var userId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.userId;
      var token = arguments.length > 2 ? arguments[2] : undefined;

      /**
       * Returns a feed object for the given feed id and token
       * @method feed
       * @memberof StreamClient.prototype
       * @param {string} feedSlug - The feed slug
       * @param {string} userId - The user identifier
       * @param {string} [token] - The token (DEPRECATED), used for internal testing
       * @return {StreamFeed}
       * @example
       * client.feed('user', '1');
       */
      if (userId instanceof _user.default) userId = userId.id;

      if (token === undefined) {
        if (this.usingApiSecret) {
          token = _signing.default.JWTScopeToken(this.apiSecret, '*', '*', {
            feedId: "".concat(feedSlug).concat(userId)
          });
        } else {
          token = this.userToken;
        }
      }

      return new _feed.default(this, feedSlug, userId, token);
    }
  }, {
    key: "enrichUrl",
    value: function enrichUrl(relativeUrl, serviceName) {
      /**
       * Combines the base url with version and the relative url
       * @method enrichUrl
       * @memberof StreamClient.prototype
       * @private
       * @param {string} relativeUrl
       */
      return "".concat(this.getBaseUrl(serviceName)).concat(this.version, "/").concat(relativeUrl);
    }
  }, {
    key: "shouldUseEnrichEndpoint",
    value: function shouldUseEnrichEndpoint() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.enrich) {
        var result = options.enrich;
        delete options.enrich;
        return result;
      }

      return this.enrichByDefault || options.ownReactions != null || options.withRecentReactions != null || options.withReactionCounts != null || options.withOwnChildren != null;
    }
  }, {
    key: "enrichKwargs",
    value: function enrichKwargs(_ref2) {
      var method = _ref2.method,
          kwargs = (0, _objectWithoutProperties2.default)(_ref2, ["method"]);

      /**
       * Adds the API key and the signature
       * @method enrichKwargs
       * @memberof StreamClient.prototype
       * @param {object} kwargs
       * @private
       */
      var signature = kwargs.signature || this.signature;

      var isJWT = _signing.default.isJWTSignature(signature);

      return _objectSpread({
        method: method,
        url: this.enrichUrl(kwargs.url, kwargs.serviceName),
        data: kwargs.body,
        params: _objectSpread({
          api_key: this.apiKey,
          location: this.group
        }, kwargs.qs || {}),
        headers: _objectSpread({
          'X-Stream-Client': this.userAgent(),
          'stream-auth-type': isJWT ? 'jwt' : 'simple',
          Authorization: isJWT ? signature.split(' ').reverse()[0] : signature
        }, kwargs.headers || {})
      }, kwargs.axiosOptions || {});
    }
  }, {
    key: "getFayeAuthorization",
    value: function getFayeAuthorization() {
      var _this2 = this;

      /**
       * Get the authorization middleware to use Faye with getstream.io
       * @method getFayeAuthorization
       * @memberof StreamClient.prototype
       * @private
       * @return {object} Faye authorization middleware
       */
      return {
        incoming: function incoming(message, callback) {
          return callback(message);
        },
        outgoing: function outgoing(message, callback) {
          if (message.subscription && _this2.subscriptions[message.subscription]) {
            var subscription = _this2.subscriptions[message.subscription];
            message.ext = {
              user_id: subscription.userId,
              api_key: _this2.apiKey,
              signature: subscription.token
            };
          }

          callback(message);
        }
      };
    }
  }, {
    key: "getFayeClient",
    value: function getFayeClient() {
      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      /**
       * Returns this client's current Faye client
       * @method getFayeClient
       * @memberof StreamClient.prototype
       * @private
       * @return {object} Faye client
       */
      if (this.fayeClient === null) {
        this.fayeClient = new _faye.default.Client(this.fayeUrl, {
          timeout: timeout
        });
        var authExtension = this.getFayeAuthorization();
        this.fayeClient.addExtension(authExtension);
      }

      return this.fayeClient;
    }
  }, {
    key: "upload",
    value: function upload(url, uri, name, contentType, onUploadProgress) {
      var fd = _utils.default.addFileToFormData(uri, name, contentType);

      return this.doAxiosRequest('POST', {
        url: url,
        body: fd,
        headers: fd.getHeaders ? fd.getHeaders() : {},
        // node vs browser
        signature: this.getOrCreateToken(),
        axiosOptions: {
          timeout: 0,
          maxContentLength: Infinity,
          maxBodyLength: Infinity,
          onUploadProgress: onUploadProgress
        }
      });
    }
  }, {
    key: "get",
    value: function get(kwargs) {
      /**
       * Shorthand function for get request
       * @method get
       * @memberof StreamClient.prototype
       * @private
       * @param  {object}    kwargs
       * @return {Promise}   Promise object
       */
      return this.doAxiosRequest('GET', kwargs);
    }
  }, {
    key: "post",
    value: function post(kwargs) {
      /**
       * Shorthand function for post request
       * @method post
       * @memberof StreamClient.prototype
       * @private
       * @param  {object}    kwargs
       * @return {Promise}   Promise object
       */
      return this.doAxiosRequest('POST', kwargs);
    }
  }, {
    key: "delete",
    value: function _delete(kwargs) {
      /**
       * Shorthand function for delete request
       * @method delete
       * @memberof StreamClient.prototype
       * @private
       * @param  {object}    kwargs
       * @return {Promise}   Promise object
       */
      return this.doAxiosRequest('DELETE', kwargs);
    }
  }, {
    key: "put",
    value: function put(kwargs) {
      /**
       * Shorthand function for put request
       * @method put
       * @memberof StreamClient.prototype
       * @private
       * @param  {object}    kwargs
       * @return {Promise}   Promise object
       */
      return this.doAxiosRequest('PUT', kwargs);
    }
    /**
     * @param {string} userId
     * @param {object} extraData
     */

  }, {
    key: "createUserToken",
    value: function createUserToken(userId) {
      var extraData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._throwMissingApiSecret();

      return _signing.default.JWTUserSessionToken(this.apiSecret, userId, extraData, {
        noTimestamp: !this.expireTokens
      });
    }
  }, {
    key: "updateActivities",
    value: function updateActivities(activities) {
      /**
       * Updates all supplied activities on the getstream-io api
       * @since  3.1.0
       * @param  {array} activities list of activities to update
       * @return {Promise}
       */
      this._throwMissingApiSecret();

      if (!(activities instanceof Array)) {
        throw new TypeError('The activities argument should be an Array');
      }

      var authToken = _signing.default.JWTScopeToken(this.apiSecret, 'activities', '*', {
        feedId: '*',
        expireTokens: this.expireTokens
      });

      return this.post({
        url: 'activities/',
        body: {
          activities: activities
        },
        signature: authToken
      });
    }
  }, {
    key: "updateActivity",
    value: function updateActivity(activity) {
      /**
       * Updates one activity on the getstream-io api
       * @since  3.1.0
       * @param  {object} activity The activity to update
       * @return {Promise}
       */
      this._throwMissingApiSecret();

      return this.updateActivities([activity]);
    }
  }, {
    key: "getActivities",
    value: function getActivities(_ref3) {
      var ids = _ref3.ids,
          foreignIDTimes = _ref3.foreignIDTimes,
          params = (0, _objectWithoutProperties2.default)(_ref3, ["ids", "foreignIDTimes"]);

      /**
       * Retrieve activities by ID or foreign ID and time
       * @since  3.19.0
       * @param  {object} params object containing either the list of activity IDs as {ids: ['...', ...]} or foreign IDs and time as {foreignIDTimes: [{foreignID: ..., time: ...}, ...]}
       * @return {Promise}
       */
      if (ids) {
        if (!(ids instanceof Array)) {
          throw new TypeError('The ids argument should be an Array');
        }

        params.ids = ids.join(',');
      } else if (foreignIDTimes) {
        if (!(foreignIDTimes instanceof Array)) {
          throw new TypeError('The foreignIDTimes argument should be an Array');
        }

        var foreignIDs = [];
        var timestamps = [];
        foreignIDTimes.forEach(function (fidTime) {
          if (!(fidTime instanceof Object)) {
            throw new TypeError('foreignIDTimes elements should be Objects');
          }

          foreignIDs.push(fidTime.foreignID);
          timestamps.push(fidTime.time);
        });
        params.foreign_ids = foreignIDs.join(',');
        params.timestamps = timestamps.join(',');
      } else {
        throw new TypeError('Missing ids or foreignIDTimes params');
      }

      var token = this.userToken;

      if (this.usingApiSecret) {
        token = _signing.default.JWTScopeToken(this.apiSecret, 'activities', '*', {
          feedId: '*',
          expireTokens: this.expireTokens
        });
      }

      this.replaceReactionOptions(params);
      var path = this.shouldUseEnrichEndpoint(params) ? 'enrich/activities/' : 'activities/';
      return this.get({
        url: path,
        qs: params,
        signature: token
      });
    }
  }, {
    key: "getOrCreateToken",
    value: function getOrCreateToken() {
      if (!this._getOrCreateToken) {
        this._getOrCreateToken = this.usingApiSecret ? _signing.default.JWTScopeToken(this.apiSecret, '*', '*', {
          feedId: '*'
        }) : this.userToken;
      }

      return this._getOrCreateToken;
    }
  }, {
    key: "user",
    value: function user(userId) {
      return new _user.default(this, userId, this.getOrCreateToken());
    }
  }, {
    key: "setUser",
    value: function () {
      var _setUser = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(data) {
        var body, user;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.usingApiSecret) {
                  _context2.next = 2;
                  break;
                }

                throw new _errors.default.SiteError('This method can only be used client-side using a user token');

              case 2:
                body = _objectSpread({}, data);
                delete body.id;
                _context2.next = 6;
                return this.currentUser.getOrCreate(body);

              case 6:
                user = _context2.sent;
                this.currentUser = user;
                return _context2.abrupt("return", user);

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setUser(_x3) {
        return _setUser.apply(this, arguments);
      }

      return setUser;
    }()
  }, {
    key: "og",
    value: function og(url) {
      return this.get({
        url: 'og/',
        qs: {
          url: url
        },
        signature: this.getOrCreateToken()
      });
    }
  }, {
    key: "personalizedFeed",
    value: function personalizedFeed() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.get({
        url: 'enrich/personalization/feed/',
        qs: options,
        signature: this.getOrCreateToken()
      });
    }
  }, {
    key: "activityPartialUpdate",
    value: function () {
      var _activityPartialUpdate = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(data) {
        var response, activity;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.activitiesPartialUpdate([data]);

              case 2:
                response = _context3.sent;
                activity = response.activities[0];
                delete response.activities;
                return _context3.abrupt("return", _objectSpread(_objectSpread({}, activity), response));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function activityPartialUpdate(_x4) {
        return _activityPartialUpdate.apply(this, arguments);
      }

      return activityPartialUpdate;
    }()
  }, {
    key: "activitiesPartialUpdate",
    value: function activitiesPartialUpdate(changes) {
      /**
       * Update multiple activities with partial operations.
       * @since v3.20.0
       * @param {array} changes array containing the changesets to be applied. Every changeset contains the activity identifier which is either the ID or the pair of of foreign ID and time of the activity. The operations to issue can be set:{...} and unset:[...].
       * @return {Promise}
       * @xample
       * client.activitiesPartialUpdate([
       *   {
       *     id: "4b39fda2-d6e2-42c9-9abf-5301ef071b12",
       *     set: {
       *       "product.price.eur": 12.99,
       *       "colors": {
       *         "blue": "#0000ff",
       *         "green": "#00ff00",
       *       },
       *     },
       *     unset: [ "popularity", "size.x2" ],
       *   },
       *   {
       *     id: "8d2dcad8-1e34-11e9-8b10-9cb6d0925edd",
       *     set: {
       *       "product.price.eur": 17.99,
       *       "colors": {
       *         "red": "#ff0000",
       *         "green": "#00ff00",
       *       },
       *     },
       *     unset: [ "rating" ],
       *   },
       * ])
       * @example
       * client.activitiesPartialUpdate([
       *   {
       *     foreignID: "product:123",
       *     time: "2016-11-10T13:20:00.000000",
       *     set: {
       *       ...
       *     },
       *     unset: [
       *       ...
       *     ]
       *   },
       *   {
       *     foreignID: "product:321",
       *     time: "2016-11-10T13:20:00.000000",
       *     set: {
       *       ...
       *     },
       *     unset: [
       *       ...
       *     ]
       *   },
       * ])
       */
      if (!(changes instanceof Array)) {
        throw new TypeError('changes should be an Array');
      }

      changes.forEach(function (item) {
        if (!(item instanceof Object)) {
          throw new TypeError("changeset should be and Object");
        }

        if (item.foreignID) {
          item.foreign_id = item.foreignID;
        }

        if (item.id === undefined && (item.foreign_id === undefined || item.time === undefined)) {
          throw new TypeError('missing id or foreign ID and time');
        }

        if (item.set && !(item.set instanceof Object)) {
          throw new TypeError('set field should be an Object');
        }

        if (item.unset && !(item.unset instanceof Array)) {
          throw new TypeError('unset field should be an Array');
        }
      });
      var authToken = this.userToken;

      if (this.usingApiSecret) {
        authToken = _signing.default.JWTScopeToken(this.apiSecret, 'activities', '*', {
          feedId: '*',
          expireTokens: this.expireTokens
        });
      }

      return this.post({
        url: 'activity/',
        body: {
          changes: changes
        },
        signature: authToken
      });
    }
  }]);
  return StreamClient;
}(); // If we are in a node environment and batchOperations is available add the methods to the prototype of StreamClient


if (_batch_operations.default) {
  Object.keys(_batch_operations.default).forEach(function (key) {
    if (Object.prototype.hasOwnProperty.call(_batch_operations.default, key)) {
      StreamClient.prototype[key] = _batch_operations.default[key];
    }
  });
} // If we are in a node environment and redirectUrl is available add the methods to the prototype of StreamClient


if (_redirect_url.default) {
  StreamClient.prototype.createRedirectUrl = _redirect_url.default;
}

var _default = StreamClient;
exports.default = _default;